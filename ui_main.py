import os, json  # ÏÉÅÎã®Ïóê Ï∂îÍ∞Ä
from PyQt5 import uic
from PyQt5.QtCore import pyqtSlot,QDateTime
from PyQt5.QtCore import QTime
from PyQt5.QtGui import QFont
from PyQt5.QtWidgets import (
    QMainWindow, QLabel, QTableWidget, QTableWidgetItem, QHeaderView,
    QGroupBox, QPushButton, QComboBox, QTextEdit,QDialog,
    QVBoxLayout, QHBoxLayout, QSizePolicy,QLineEdit,QButtonGroup, QTabWidget, QWidget,QApplication
)
from PyQt5.QtWidgets import QAction
from config_dialog import ConfigDialog
from config_manager import save_user_config, load_user_config
from schedule_settings_dialog import ScheduleSettingsDialog
from PyQt5.QtWidgets import QMessageBox
import datetime
from utils import update_debug_flags
from PyQt5.QtCore import Qt
from kiwoom_api import KiwoomAPI
from strategy_manager import save_current_strategy
from strategy_manager import load_strategy
from account_manager import AccountManager
from utils import log
from modules.watchlist_view import update_watchlist_status, display_condition_results
# üì¶ Í¥ÄÏã¨Ï¢ÖÎ™© Í∏∞Îä• Í¥ÄÎ†® Î™®Îìà
from modules.condition_manager import ConditionManager
from modules.google_loader import fetch_google_sheet_data
from modules.watchlist_view import display_watchlist, update_watchlist_price
from modules.tr_handler import handle_watchlist_tr_data
from modules.tr_codes import TR_WATCHLIST_DETAILS
from buy_sell_settings_groupbox import create_buy_settings_groupbox, create_sell_settings_groupbox
# from strategy_selector_widget import create_strategy_selector_widget
from strategy_manager import delete_strategy
from strategy_executor import AutoTradeExecutor
# from buy_sell_settings_groupbox import register_chejan_handler
from PyQt5.QtCore import QTimer
from modules.telegram_utils import configure_telegram
from modules.all_holdings_popup import AllHoldingsPopup
from modules.tr_codes import SCR_REALTIME_CONDITION

from utils import log_trade
from utils import (
    log_debug,
    log_info,
    log_trade,
    SHOW_DEBUG,
    SHOW_VERBOSE_BUY_EVAL,
    SHOW_VERBOSE_SELL_EVAL
)

# ‚úÖ Ïä§ÌÉÄÏùº ÏÉÅÏàò Ï∂îÍ∞Ä
UNIFORM_BUTTON_STYLE = """
QPushButton {
    min-width: 100px;
    max-width: 100px;
    min-height: 20px;
    max-height: 20px;
    font-size: 12px;
    padding: 4px;
}
"""
TRADING_STYLE = """
QPushButton {
    background-color: #ff4d4d;   /* Îπ®Í∞ÑÏÉâ Î∞∞Í≤Ω */
    color: white;                /* Ìù∞ÏÉâ Í∏ÄÏûê */
    font-weight: bold;
    border: 1px solid #cc0000;   /* ÏßÑÌïú ÌÖåÎëêÎ¶¨ */
    border-radius: 6px;
    padding: 4px 12px;
}
"""
SELECTED_STYLE = """
QPushButton {
    background-color: #cce5ff;
    color: black;
    border: 1px solid #3399ff;
    font-size: 12px;
    font-weight: normal;
    border-radius: 6px;
    padding: 4px 12px;
}
"""
LOGIN_STYLE = """
QPushButton {
    background-color: #4CAF50;
    color: white;
    font-weight: bold;
    border: 1px solid #2e7d32;
    border-radius: 6px;
    padding: 4px 12px;
    min-width: 100px;
    max-width: 100px;
}
"""
UNSELECTED_STYLE = """
QPushButton {
    background-color: #f9f9f9;
    color: #333;
    border: 1px solid #ccc;
    font-size: 12px;
    font-weight: normal;
    border-radius: 6px;
    padding: 4px 12px;
}
QPushButton:hover {
    background-color: #eaeaea;
}
"""
LABEL_STYLE = """
QLabel {
    font-size: 13px;
    font-weight: bold;
    color: #333;
}
"""
TAB_STYLE = """
QTabBar::tab {
    font-size: 12px;
    font-weight: bold;
    font-family: "ÎßëÏùÄ Í≥†Îîï";       /* Ìè∞Ìä∏ Î™ÖÏãúÏ†ÅÏúºÎ°ú ÏÑ§Ï†ï */
    padding: 4px 8px;
    min-height: 20px;
    color: #333333;
}
"""

# ‚úÖ Í∑∏Î£πÎ∞ïÏä§ Ïä§ÌÉÄÏùº ÏÉÅÏàò
GROUPBOX_STYLE = """
QGroupBox {
    font-size: 12px;
    font-weight: bold;
    color: #333333;
}
"""
CLOCK_LABEL_STYLE = """
QLabel {
    background-color: black;
    color: yellow;
    font-size: 13px;
    font-weight: bold;
    padding: 6px 12px;
    min-height: 20px;
}
"""
class AutoTradeUI(QMainWindow):
    def __init__(self):
        super().__init__()
        uic.loadUi("ui/autotrade.ui", self)

        self.setup_fonts()
        self.setup_clock()
        self.setup_buttons()
        self.setup_strategy_ui()
        self.setup_schedule_timer()
        self.setup_tabs()
        self.setup_config()
        self.setup_tables()
        self.setup_log()
        self.setup_account_sections()
        self.setup_misc_ui()
        self.setup_menu_actions()
        self.refresh_schedule_dropdown_main()
        self.connect_signals()
        self.received_balance_accounts = set()
        self.trade_start_button.setEnabled(False)

    def setup_fonts(self):
        self.setFont(QFont("ÎßëÏùÄ Í≥†Îîï", 8))

    def setup_clock(self):
        self.clock_label = QLabel()
        self.clock_label.setStyleSheet(CLOCK_LABEL_STYLE)
        self.clock_label.setAlignment(Qt.AlignCenter)
        self.update_clock()

        self.clock_timer = QTimer(self)
        self.clock_timer.timeout.connect(self.update_clock)
        self.clock_timer.start(1000)

        self.topBar = self.findChild(QHBoxLayout, "topBar")
        self.topBar.addWidget(self.clock_label)

    def setup_buttons(self):
        button_names = [
            "login_button", "trade_start_button", "trade_stop_button",
            "strategy_save_button", "strategy_delete_button", "view_all_holdings_button",
            "schedule_enabled_button", "schedule_button", "config_button"
        ]
        for name in button_names:
            btn = self.findChild(QPushButton, name)
            if btn:
                btn.setStyleSheet(UNIFORM_BUTTON_STYLE)
                btn.setFixedWidth(100)

    def setup_strategy_ui(self):
        self.strategy_dropdown = self.findChild(QComboBox, "strategy_dropdown")
        self.strategy_name_input = self.findChild(QLineEdit, "strategy_name_input")
        self.strategy_name_input.setMaximumWidth(250)
        self.load_existing_strategies()

    def setup_schedule_timer(self):
        self.schedule_timer = QTimer(self)
        self.schedule_timer.timeout.connect(self.check_schedule_and_apply)
        self.schedule_timer.start(1000 * 30)

    def setup_tabs(self):
        self.account_tab = self.findChild(QTabWidget, "account_tab")
        self.watchlist_tabwidget = self.findChild(QTabWidget, "watchlist_tabwidget")
        tab_font = QFont("ÎßëÏùÄ Í≥†Îîï", 10)
        for tab in [self.account_tab, self.watchlist_tabwidget]:
            if tab:
                tab.setStyleSheet(TAB_STYLE)
                tab.tabBar().setFont(tab_font)
        if self.account_tab:
            self.account_tab.setTabText(0, "üìä ÏûîÍ≥†")
            self.account_tab.setTabText(1, "üì¶ ÎØ∏Ï≤¥Í≤∞")
            self.account_tab.setTabText(2, "üßæ Îß§Îß§ÎÇ¥Ïó≠")

    def setup_config(self):
        self.config = load_user_config()
        update_debug_flags(self.config)
        self.sheet_id = self.config.get("sheet_id", "")
        self.sheet_name = self.config.get("sheet_name", "Í¥ÄÏã¨Ï¢ÖÎ™©")
        token = self.config.get("telegram_token", "")
        chat_id = self.config.get("telegram_chat_id", "")
        if token and chat_id:
            configure_telegram(token, chat_id)

    def setup_tables(self):
        self.setup_core_objects()
        self.setup_stock_search_table()
        self.setup_holdings_table()
        self.setup_condition_table()
        self.setup_unsettled_table()
        self.setup_trade_log_table()
        self.setup_table_fonts()

    def setup_log(self):
        self.log_box = self.findChild(QTextEdit, "log_box")
        self.log_box.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        log_trade.log_widget = self.log_box
        log_label = self.findChild(QLabel, "log_label")
        if log_label:
            log_label.setStyleSheet(LABEL_STYLE)
            log_label.setAlignment(Qt.AlignLeft)
        log_container = self.log_label.parentWidget()
        if log_container:
            layout = log_container.layout()
            if layout:
                layout.setContentsMargins(10, 0, 10, 10)

    def setup_account_sections(self):
        buy_box = create_buy_settings_groupbox()
        sell_box = create_sell_settings_groupbox()
        self.buy_settings_group.layout().addWidget(buy_box)
        self.sell_settings_group.layout().addWidget(sell_box)

        self.buy_order_type_combo = buy_box.findChild(QComboBox, "buy_order_type_combo")
        self.buy_test_mode_checkbox = buy_box.findChild(QPushButton, "buy_test_mode_checkbox")
        self.buy_account_buttons = [buy_box.findChild(QPushButton, f"buy_account_button_{i+1}") for i in range(4)]
        self.buy_amount_inputs = [buy_box.findChild(QLineEdit, f"buy_amount_input_{i+1}") for i in range(4)]
        self.buy_drop_inputs = [buy_box.findChild(QLineEdit, f"buy_drop_input_{i+1}") for i in range(4)]

        self.sell_order_type_combo = sell_box.findChild(QComboBox, "sell_order_type_combo")
        self.sell_account_buttons = [sell_box.findChild(QPushButton, f"sell_account_button_{i+1}") for i in range(4)]
        self.sell_ratio_inputs = [sell_box.findChild(QLineEdit, f"sell_ratio_input_{i+1}") for i in range(4)]
        self.sell_profit_inputs = [sell_box.findChild(QLineEdit, f"sell_profit_input_{i+1}") for i in range(4)]

        self.max_holdings_input = self.findChild(QLineEdit, "max_holdings_input")
        self.max_holdings_input.setText("10")
        self.max_holdings_input.setMaximumWidth(40)
        self.max_holdings_input.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        self.max_holdings_input.setAlignment(Qt.AlignCenter)
        font_input = self.max_holdings_input.font()
        font_input.setBold(True)
        self.max_holdings_input.setFont(font_input)

        self.setup_account_buttons()
        self.setup_table_styles()

    def setup_misc_ui(self):
        self.watchlist = []
        self.manager.set_ui_elements(
            self.account_combo,
            self.account_info_label,
            self.holdings_table,
            self.log_box,
            self.unsettled_table,
        )
        self.manager.trade_log_table = self.trade_log_table
        self.manager.stock_search_table = self.stock_search_table

        self.condition_manager = ConditionManager(self.api, log_fn=lambda msg: log(self.log_box, msg))

        self.api.ocx.OnEventConnect.connect(self.on_login_event)
        self.api.ocx.OnReceiveTrData.connect(self.handle_tr_data)
        self.api.ocx.OnReceiveRealData.connect(self.on_real_data)

        watchlist_label = self.findChild(QLabel, "watchlist_label")
        if watchlist_label:
            watchlist_label.setStyleSheet(LABEL_STYLE)
            watchlist_label.setAlignment(Qt.AlignLeft)
        tab_watchlist = self.findChild(QWidget, "tab_watchlist")
        if tab_watchlist:
            layout = tab_watchlist.layout()
            if layout:
                layout.setContentsMargins(10, 0, 10, 10)

        layout = self.findChild(QHBoxLayout, "topInfoLayout")
        if layout:
            layout.setStretch(0, 1)
            layout.setStretch(1, 1)
            layout.setStretch(2, 3)
            layout.setStretch(3, 3)

        self.condition_dropdown = self.findChild(QComboBox, "condition_dropdown")
        self.condition_search_button = self.findChild(QPushButton, "condition_search_button")
        self.is_fullscreen = False
   
    def setup_core_objects(self):
        self.api = KiwoomAPI()
        self.basic_info_map = {}

        self.manager = AccountManager(self.api, self.config)
        self.manager.ui = self

        self.executor = AutoTradeExecutor(self.api)
        self.executor.set_manager(self.manager)
        self.executor.set_basic_info_map(self.basic_info_map)

        self.manager.set_executor(self.executor)
        self.manager.basic_info_map = self.basic_info_map

        # ‚úÖ Ïª®Ìä∏Î°§Îü¨ Ï¥àÍ∏∞Ìôî
        from modules.watchlist_controller import WatchlistController
        from modules.condition_controller import ConditionSearchController

        self.watchlist_controller = WatchlistController(self, self.api, lambda msg: log(self.log_box, msg))
        self.condition_controller = ConditionSearchController(self, self.api, lambda msg: log(self.log_box, msg))

        # ‚úÖ Ïã§ÏãúÍ∞Ñ Ï°∞Í±¥Í≤ÄÏÉâ Ïù¥Î≤§Ìä∏ Ïó∞Í≤∞
        self.api.ocx.OnReceiveRealCondition.connect(self.condition_controller.on_receive_real_condition)
       
    def connect_signals(self):
        self.login_button.clicked.connect(self.login)
        self.trade_start_button.clicked.connect(self.handle_trade_start)
        self.trade_stop_button.clicked.connect(self.handle_trade_stop)
        self.view_all_holdings_button.clicked.connect(self.show_all_holdings_popup)
        self.watchlist_button.clicked.connect(
            lambda: self.watchlist_controller.load_watchlist_from_google(self.sheet_id, self.sheet_name)
        )

        if self.schedule_button:
            self.schedule_button.setStyleSheet(UNIFORM_BUTTON_STYLE)
            self.schedule_button.clicked.connect(self.open_schedule_settings)

        if self.config_button:
            self.config_button.setStyleSheet(UNIFORM_BUTTON_STYLE)
            self.config_button.clicked.connect(lambda: self.open_config_dialog(first_time=False))

        self.schedule_enabled_button.setCheckable(False)
        self.schedule_enabled_button.toggled.connect(self.on_schedule_toggle)

        self.condition_auto_buy_checkbox.setChecked(False)  # ÏÉÅÌÉú ÌôïÏã§Ìûà FalseÎ°ú ÏÑ§Ï†ï
        self.condition_auto_buy_checkbox.toggled.connect(self.toggle_condition_auto_buy)

        self.schedule_dropdown_main.currentTextChanged.connect(self.load_selected_schedule)
        self.strategy_save_button.clicked.connect(self.handle_save_strategy)
        self.strategy_delete_button.clicked.connect(self.handle_delete_strategy)
        self.strategy_dropdown.currentTextChanged.connect(self.handle_strategy_selected)

        self.account_combo.currentTextChanged.connect(self.manager.request_deposit_info)
        self.account_combo.currentTextChanged.connect(self.handle_account_selected)

        self.api.ocx.OnReceiveTrCondition.connect(self.condition_controller.on_receive_tr_condition)
        self.api.ocx.OnReceiveConditionVer.connect(self.condition_controller.on_condition_loaded)
        self.condition_search_button.clicked.connect(self.condition_controller.handle_search)
        self.api.ocx.OnReceiveRealCondition.connect(self.condition_controller.on_receive_real_condition)

    def setup_buttons(self):
        # ÏùºÎ∞ò Î≤ÑÌäºÎì§: Ïä§ÌÉÄÏùºÎßå Ï†ÅÏö© (ÏãúÍ∑∏ÎÑê Ïó∞Í≤∞ÏùÄ connect_signalsÏóêÏÑú)
        button_names = [
            "config_button", "schedule_button", "login_button",
            "trade_start_button", "trade_stop_button",
            "view_all_holdings_button", "watchlist_button",
            "strategy_save_button", "strategy_delete_button",
            "condition_search_button"
        ]

        for name in button_names:
            btn = self.findChild(QPushButton, name)
            if btn:
                btn.setStyleSheet(UNIFORM_BUTTON_STYLE)
                btn.setFixedWidth(100)

        # Ï≤¥ÌÅ¨ Í∞ÄÎä•Ìïú Î≤ÑÌäº: Ï≤¥ÌÅ¨ ÏÑ§Ï†ïÎßå (ÏãúÍ∑∏ÎÑêÏùÄ connect_signalsÏóêÏÑú)
        toggle_names = ["schedule_enabled_button", "condition_auto_buy_checkbox"]
        for name in toggle_names:
            btn = self.findChild(QPushButton, name)
            if btn:
                btn.setCheckable(True)

    def setup_holdings_table(self):
        self.holdings_table = self.findChild(QTableWidget, "holdings_table")
        if self.holdings_table:
            self.holdings_table.setColumnCount(9)
            self.holdings_table.setHorizontalHeaderLabels([
                "Ï¢ÖÎ™©Î™Ö", "Î≥¥Ïú†ÏàòÎüâ", "Îß§ÏûÖÍ∞Ä", "ÌòÑÏû¨Í∞Ä", "Î™©ÌëúÎã®Í∞Ä",
                "ÏàòÏùµÎ•†(%)", "Îß§ÏûÖÍ∏àÏï°", "ÌèâÍ∞ÄÍ∏àÏï°", "ÌèâÍ∞ÄÏÜêÏùµ"
            ])
            self.holdings_table.setEditTriggers(QTableWidget.NoEditTriggers)
            self.holdings_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
            self.holdings_table.verticalHeader().setDefaultSectionSize(30)
            self.holdings_table.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

            self.manager.holdings_table = self.holdings_table
        else:
            log(self.log_box, "‚ùå 'holdings_table' ÏúÑÏ†ØÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")

    def setup_stock_search_table(self):
        self.stock_search_table = self.findChild(QTableWidget, "stock_search_table")
        if self.stock_search_table:
            self.stock_search_table.setColumnCount(7)
            self.stock_search_table.setHorizontalHeaderLabels([
                "Ï¢ÖÎ™©ÏΩîÎìú", "Ï¢ÖÎ™©Î™Ö", "Ï†ÑÏùºÏ¢ÖÍ∞Ä", "ÌòÑÏû¨Í∞Ä", "Îì±ÎùΩÎ•†", "ÏÉÅÌÉú", "Îß§Ïàò"
            ])
            self.stock_search_table.setEditTriggers(QTableWidget.NoEditTriggers)
            self.stock_search_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
            self.stock_search_table.verticalHeader().setDefaultSectionSize(30)
            self.stock_search_table.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

            self.manager.stock_search_table = self.stock_search_table
        else:
            log(self.log_box, "‚ùå 'stock_search_table' ÏúÑÏ†ØÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")

    def setup_condition_table(self):
        self.condition_table = self.findChild(QTableWidget, "condition_table")
        if self.condition_table:
            self.condition_table.setColumnCount(7)
            self.condition_table.setHorizontalHeaderLabels([
                "Ï¢ÖÎ™©ÏΩîÎìú", "Ï¢ÖÎ™©Î™Ö", "Ï†ÑÏùºÏ¢ÖÍ∞Ä", "ÌòÑÏû¨Í∞Ä", "Îì±ÎùΩÎ•†", "Ï°∞Í±¥ÏãùÎ™Ö", "Îß§Ïàò"
            ])
            self.condition_table.setEditTriggers(QTableWidget.NoEditTriggers)
            self.condition_table.verticalHeader().setDefaultSectionSize(28)

            self.manager.condition_table = self.condition_table  # ÌïÑÏöîÏãú
        else:
            log(self.log_box, "‚ùå 'condition_table' ÏúÑÏ†ØÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")
   
    def setup_unsettled_table(self):
        self.unsettled_table = self.findChild(QTableWidget, "unsettled_table")
        if self.unsettled_table:
            self.unsettled_table.setColumnCount(7)
            self.unsettled_table.setHorizontalHeaderLabels([
                "Ï£ºÎ¨∏Î≤àÌò∏", "Ï¢ÖÎ™©Î™Ö", "Íµ¨Î∂Ñ", "Ï£ºÎ¨∏ÏàòÎüâ", "Ï≤¥Í≤∞ÏàòÎüâ", "ÏûîÎüâ", "Í∞ÄÍ≤©"
            ])
            self.unsettled_table.setEditTriggers(QTableWidget.NoEditTriggers)
            self.unsettled_table.verticalHeader().setDefaultSectionSize(28)

            self.manager.unsettled_table = self.unsettled_table  # ÌïÑÏöîÏãú
        else:
            log(self.log_box, "‚ùå 'unsettled_table' ÏúÑÏ†ØÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")

    def setup_trade_log_table(self):
        self.trade_log_table = self.findChild(QTableWidget, "trade_log_table")
        if self.trade_log_table:
            self.trade_log_table.setColumnCount(14)
            self.trade_log_table.setHorizontalHeaderLabels([
                "ÏùºÏûê", "ÏãúÍ∞Ñ", "Í≥ÑÏ¢å", "Ï¢ÖÎ™©ÏΩîÎìú", "Ï¢ÖÎ™©Î™Ö", "Íµ¨Î∂Ñ",
                "ÏàòÎüâ", "Í∞ÄÍ≤©", "Ï≤¥Í≤∞Í∏àÏï°", "ÏàòÏàòÎ£å", "ÏÑ∏Í∏à", "Ï†ïÏÇ∞Í∏àÏï°", "Ï†ÑÎûµÎ™Ö", "ÎπÑÍ≥†"
            ])
            self.trade_log_table.setEditTriggers(QTableWidget.NoEditTriggers)
            self.trade_log_table.verticalHeader().setDefaultSectionSize(28)

            self.manager.trade_log_table = self.trade_log_table  # ÌïÑÏöîÏãú
        else:
            log(self.log_box, "‚ùå 'trade_log_table' ÏúÑÏ†ØÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")

    def setup_table_fonts(self):
        font_header = QFont("ÎßëÏùÄ Í≥†Îîï", 8)
        for table in [
            self.holdings_table,
            self.stock_search_table,
            self.condition_table,
            self.unsettled_table,
            self.trade_log_table
        ]:
            if table:
                table.horizontalHeader().setFont(font_header)
                
    def setup_table_styles(self):
        font_header = QFont("ÎßëÏùÄ Í≥†Îîï", 9)     # Ìó§Îçî: ÍµµÍ≥† ÌÅ¨Í≤å
        font_body = QFont("ÎßëÏùÄ Í≥†Îîï", 10)                  # Î≥∏Î¨∏: ÏùºÎ∞ò ÌÅ¨Í∏∞

        for table in [self.holdings_table, self.stock_search_table, self.condition_table, self.unsettled_table,self.trade_log_table]:
            # Î≥∏Î¨∏ Í∏ÄÍº¥ ÏÑ§Ï†ï
            table.setFont(font_body)

            # Ìó§Îçî Í∏ÄÍº¥ ÏÑ§Ï†ï (ÏàòÌèâ Ìó§ÎçîÎßå Ï°∞Ï†ï)
            header = table.horizontalHeader()
            header.setFont(font_header)

            # Ïä§ÌÉÄÏùº Î≥¥ÏôÑ (ÏÉâÏÉÅÎßå Ïä§ÌÉÄÏùºÏãúÌä∏Î°ú)
            table.setStyleSheet("""
                QTableWidget {
                    background-color: #f0f0f0;
                }
                QHeaderView::section {
                    background-color: #e6e6e6;
                    padding: 2px;
                    border: 1px solid #aaa;
                }
            """)

        # Î°úÍ∑∏Ï∞ΩÏùÄ Í∏∞Ï°¥ÎåÄÎ°ú Ïú†ÏßÄ
        self.log_box.setStyleSheet("""
            QTextEdit {
                background-color: black;
                color: white;
                font-family: Consolas, monospace;
                font-size: 12px;
            }
        """)

    def set_buy_settings_to_ui(self, buy_data):
        self.buy_order_type_combo.setCurrentText(buy_data.get("order_type", "ÏãúÏû•Í∞Ä"))
        self.buy_test_mode_checkbox.setChecked(buy_data.get("test_mode", False))

        for i, acc in enumerate(["Í≥ÑÏ¢å1", "Í≥ÑÏ¢å2", "Í≥ÑÏ¢å3", "Í≥ÑÏ¢å4"]):
            acc_data = buy_data["accounts"].get(acc, {})
            self.buy_account_buttons[i].setChecked(acc_data.get("enabled", False))
            amount = int(acc_data.get("amount", 0))
            self.buy_amount_inputs[i].setText(f"{amount:,}")
            self.buy_drop_inputs[i].setText(str(acc_data.get("drop_rate", 0.0)))

    def set_sell_settings_to_ui(self, sell_data):
        self.sell_order_type_combo.setCurrentText(sell_data.get("order_type", "ÏãúÏû•Í∞Ä"))

        for i, acc in enumerate(["Í≥ÑÏ¢å1", "Í≥ÑÏ¢å2", "Í≥ÑÏ¢å3", "Í≥ÑÏ¢å4"]):
            acc_data = sell_data["accounts"].get(acc, {})
            self.sell_account_buttons[i].setChecked(acc_data.get("enabled", False))
            self.sell_ratio_inputs[i].setText(str(acc_data.get("ratio", 0)))
            self.sell_profit_inputs[i].setText(str(acc_data.get("profit_rate", 0.0)))      
            
    def setup_account_buttons(self):
        self.account_buttons = [
            self.findChild(QPushButton, "account_button_1"),
            self.findChild(QPushButton, "account_button_2"),
            self.findChild(QPushButton, "account_button_3"),
            self.findChild(QPushButton, "account_button_4"),
        ]

        self.account_button_group = QButtonGroup()
        self.account_button_group.setExclusive(True)  # ‚úÖ Îã®Ïùº ÏÑ†ÌÉùÎßå Í∞ÄÎä•

        for i, btn in enumerate(self.account_buttons):
            btn.setCheckable(True)
            self.account_button_group.addButton(btn, i)

        self.account_button_group.buttonClicked[int].connect(self.handle_account_button_clicked)

    def handle_account_button_clicked(self, index):
        if hasattr(self, 'executor') and self.executor.accounts:
            account = self.executor.accounts[index]
            self.account_combo.setCurrentText(account)

        for i, btn in enumerate(self.account_buttons):
            if i == index:
                btn.setStyleSheet(SELECTED_STYLE)
            else:
                btn.setStyleSheet(UNSELECTED_STYLE)

    def handle_account_selected(self, account):
        is_same_account = account == self.manager.current_account
        self.current_account = account
        self.manager.current_account = account  # ‚úÖ ÏÉÅÌÉú ÎèôÍ∏∞Ìôî

        self.manager.request_deposit_info(account)
        self.manager.request_estimated_asset(account)

        # ‚úÖ Ï§ëÎ≥µ ÏöîÏ≤≠ Î∞©ÏßÄ: ÎèôÏùº Í≥ÑÏ¢å + ÏûîÍ≥† Ïù¥ÎØ∏ Î°úÎìúÎêú Í≤ΩÏö∞ ÏÉùÎûµ
        if not is_same_account or not self.manager.holdings_loaded:
            self.manager.request_holdings(account)

        self.manager.request_today_profit(account)
        self.manager.request_order_history(account)

        if not is_same_account:
            self.manager.refresh_holdings_ui()  # ÌÖåÏù¥Î∏îÏùÄ Í≥ÑÏ¢å Î≥ÄÍ≤Ω ÏãúÎßå Í∞±Ïã†

        # Î≤ÑÌäº ÏãúÍ∞Å ÎèôÍ∏∞Ìôî
        for i, acc in enumerate(self.executor.accounts):
            if acc == account:
                self.account_buttons[i].setChecked(True)
                self.account_buttons[i].setStyleSheet(SELECTED_STYLE)
            else:
                self.account_buttons[i].setChecked(False)
                self.account_buttons[i].setStyleSheet(UNSELECTED_STYLE)

    @pyqtSlot()
    def start_realtime_updates(self):
        self.manager.start_realtime_updates()
        
    def on_holdings_loaded(self):
        print("‚úÖ ÏûîÍ≥† ÏàòÏã† ÏôÑÎ£å ‚Üí Îß§Îß§ ÏãúÏûë Î≤ÑÌäº ÌôúÏÑ±Ìôî")
        self.manager.holdings_loaded = True
        self.trade_start_button.setEnabled(True)

        # ‚úÖ Ïó¨Í∏∞ÏÑú Î≥¥Ïú† Í∏∞Î∞ò Î≥µÏõê Î°úÏßÅ Ïã§Ìñâ
        self.executor.holdings = self.manager.holdings
        self.executor.reconstruct_buy_history_from_holdings()
        self.executor.reconstruct_sell_history_from_holdings()
        self.executor.reconstruct_pending_buys_from_unsettled()
    
    @pyqtSlot()
    def login(self):
        log(self.log_box, "üîë Î°úÍ∑∏Ïù∏ ÏöîÏ≤≠ Ï§ë...")
        self.api.connect()


    def on_login_event(self, err_code):
        self.manager.handle_login_event(err_code)

        if err_code != 0:
            log(self.log_box, f"‚ùå Î°úÍ∑∏Ïù∏ Ïã§Ìå®: ÏΩîÎìú {err_code}")
            return

        log(self.log_box, "‚úÖ Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µ")

        # ‚úÖ Ï≤¥Í≤∞ Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨ Îì±Î°ù
        self.api.register_chejan_handler(self.executor.handle_chejan_data)
        print("‚úÖ Ï≤¥Í≤∞ Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨ Îì±Î°ù ÏôÑÎ£å")

        # ‚úÖ Í≥ÑÏ¢å Î™©Î°ù ÏÑ∏ÌåÖ
        accounts = [self.account_combo.itemText(i) for i in range(self.account_combo.count())]
        self.accounts = accounts
        self.executor.set_accounts(accounts)

        # ‚úÖ holdings Ï∂îÏ†ÅÏö© ÏÑ∏ÌåÖ
        self.manager.expected_accounts = set(accounts)
        self.manager.received_accounts = set()
        self.manager.holdings_loaded = False

        if accounts:
            first_account = accounts[0]
            self.first_account = first_account
            self.account_combo.setCurrentText(first_account)

            def after_holdings_loaded():
                self.on_holdings_loaded()
                self.handle_account_selected(first_account)
                self.manager.request_today_profit(first_account)
                self.manager.request_estimated_asset(first_account)

            # ‚úÖ Ï†ÑÏ≤¥ ÏûîÍ≥† ÏöîÏ≤≠ ÏãúÏûë
            self.manager.request_all_holdings(accounts, on_complete=after_holdings_loaded)

        # ‚úÖ Í∏∞Î≥∏ Ï†ÑÎûµ ÏûêÎèô Î°úÎìú
        if self.strategy_dropdown and self.strategy_dropdown.findText("Í∏∞Î≥∏") != -1:
            self.strategy_dropdown.setCurrentText("Í∏∞Î≥∏")
            self.handle_strategy_selected("Í∏∞Î≥∏")

        # ‚úÖ Ï°∞Í±¥Ïãù Î°úÎìú
        self.api.ocx.dynamicCall("GetConditionLoad()")
           

    def start_auto_trade(self):
        if not getattr(self.manager, "holdings_loaded", False):
            QMessageBox.warning(self, "‚è≥ ÏûîÍ≥† ÏàòÏã† Ï§ë", "Î≥¥Ïú† Ï¢ÖÎ™© Ï†ïÎ≥¥Î•º ÏïÑÏßÅ ÏàòÏã†ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.")
            return

        # ‚úÖ ÌòÑÏû¨ ÏÑ†ÌÉùÎêú Ï†ÑÎûµÎ™Ö ÌôïÏù∏
        selected_strategy = self.strategy_dropdown.currentText()
        if not selected_strategy:
            QMessageBox.warning(self, "‚ùå Ï†ÑÎûµ ÏóÜÏùå", "ÏûêÎèôÎß§Îß§Î•º ÏãúÏûëÌïòÍ∏∞ Ï†ÑÏóê Ï†ÑÎûµÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.")
            return

        # ‚úÖ Ïù¥ÎØ∏ Í∞ôÏùÄ Ï†ÑÎûµÏù¥ Ï†ÅÏö©ÎêòÏñ¥ ÏûàÎã§Î©¥ Ï§ëÎ≥µ Ï†ÅÏö© Î∞©ÏßÄ
        if hasattr(self.executor, "current_strategy_name") and self.executor.current_strategy_name == selected_strategy:
            log(self.log_box, f"‚ö†Ô∏è Ï†ÑÎûµ '{selected_strategy}'ÏùÄ Ïù¥ÎØ∏ Ï†ÅÏö©ÎêòÏñ¥ ÏûàÏäµÎãàÎã§.")
        else:
            self.handle_strategy_selected(selected_strategy)

        if not self.executor.buy_settings.get("accounts"):
            QMessageBox.warning(self, "‚ö†Ô∏è Ï†ÑÎûµ ÏÑ§Ï†ï ÏóÜÏùå", "ÏÑ†ÌÉùÌïú Ï†ÑÎûµÏóê Îß§Ïàò Ï°∞Í±¥Ïù¥ ÏóÜÏäµÎãàÎã§.")
            return

        log(self.log_box, "‚úÖ ÏûêÎèôÎß§Îß§ Ï§ÄÎπÑ Ï§ë ‚Üí ÏÉÅÌÉú Î≥µÏõê Ï§ë...")

        # ‚úÖ Ï≤¥Í≤∞ ÎåÄÍ∏∞ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
        log(self.log_box, f"üßπ pending_buys Ï¥àÍ∏∞Ìôî Ï†Ñ: {len(self.executor.pending_buys)}Í±¥")
        self.executor.pending_buys.clear()
        log(self.log_box, "üßπ Ï≤¥Í≤∞ÎåÄÍ∏∞ Ï¢ÖÎ™© Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")

        # ‚úÖ Î≥¥Ïú† ÏÉÅÌÉú Î≥µÏõê
        self.executor.holdings = self.manager.holdings
        self.executor.reconstruct_buy_history_from_holdings()
        self.executor.reconstruct_sell_history_from_holdings()
        log(self.log_box, "üîÅ Îß§Ïàò/Îß§ÎèÑ Îã®Í≥Ñ ÏûêÎèô Î≥µÏõê ÏôÑÎ£å")

        # ‚úÖ Ï†ÑÎûµÎ™Ö ÎàÑÎùΩ Î∞©ÏßÄ
        if not hasattr(self.executor, "current_strategy_name") or self.executor.current_strategy_name == "Ï†ÑÎûµÎØ∏ÏßÄÏ†ï":
            log(self.log_box, "‚ùó Ï†ÑÎûµÎ™ÖÏù¥ Ï†ÅÏö©ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Ï†ÑÎûµÏùÑ Îã§Ïãú ÏÑ†ÌÉùÌï¥ Ï£ºÏÑ∏Ïöî.")
            return

        # ‚úÖ Í≥ÑÏ¢åÍ∞Ä ÌïòÎÇò Ïù¥ÏÉÅ ÏûàÎã§Î©¥ Î™ÖÏãúÏ†ÅÏúºÎ°ú Ï≤´ Í≥ÑÏ¢å ÏÑ†ÌÉù
        if self.executor.accounts:
            first_account = self.executor.accounts[0]
            self.account_combo.setCurrentText(first_account)  # ÏΩ§Î≥¥Î∞ïÏä§ Î≥ÄÍ≤Ω ‚Üí ÏûîÍ≥† Î°úÎî© Ïú†ÎèÑ
            self.manager.current_account = first_account

        # ‚úÖ ÏûêÎèôÎß§Îß§ Ï¶âÏãú ÌôúÏÑ±Ìôî
        self.executor.enabled = True
        log(self.log_box, "‚úÖ ÏûêÎèôÎß§Îß§ Ï¶âÏãú ÌôúÏÑ±Ìôî ÏôÑÎ£å")



    def enable_auto_trade(self):
        self.executor.enabled = True
        log(self.log_box, "‚úÖ ÏûêÎèôÎß§Îß§ ÌôúÏÑ±Ìôî ÏôÑÎ£å (Î≥¥Ïú† Ï¢ÖÎ™© Î≥µÏõê Ïù¥ÌõÑ)")

    def handle_trade_start(self):
        if not getattr(self.manager, "holdings_loaded", False):
            log(self.log_box, "‚ùå Îß§Îß§ ÏãúÏûë Ïã§Ìå®: ÏûîÍ≥† ÏàòÏã†Ïù¥ ÏïÑÏßÅ ÏôÑÎ£åÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.")
            return

        self.start_auto_trade()
        self.trade_start_button.setText("Îß§Îß§Ï§ë")
        self.trade_start_button.setStyleSheet(UNIFORM_BUTTON_STYLE + TRADING_STYLE)
        self.trade_stop_button.setStyleSheet(UNIFORM_BUTTON_STYLE)
        
    def stop_auto_trade(self):
        self.executor.enabled = False
        log(self.log_box, "üõë ÏûêÎèôÎß§Îß§ Ï¢ÖÎ£å")
        
    def handle_trade_stop(self):
        self.stop_auto_trade()  # ‚úÖ Í∏∞Ï°¥ Î°úÏßÅ Ìò∏Ï∂ú
        self.trade_start_button .setText("Îß§Îß§ ÏãúÏûë")
        self.trade_start_button .setStyleSheet(UNIFORM_BUTTON_STYLE)
        self.trade_stop_button.setStyleSheet(UNIFORM_BUTTON_STYLE)

    @pyqtSlot("QString", "QString", "QString")
    def on_real_data(self, code, real_type, data):
        # print(f"[Ïã§ÏãúÍ∞Ñ ÏàòÏã†] {code} / {real_type} / enabled={self.executor.enabled}")
        if real_type == "Ï£ºÏãùÏ≤¥Í≤∞":
            price_str = self.api.ocx.dynamicCall("GetCommRealData(QString, int)", code, 10).strip()

            if not price_str:
                log(self.log_box, f"‚ö†Ô∏è Ïã§ÏãúÍ∞Ñ ÌòÑÏû¨Í∞Ä ÏóÜÏùå, TRÎ°ú Î≥¥ÏôÑ ÏöîÏ≤≠: {code}")
                self.request_price_tr_for_code(code)
                return

            try:
                price = abs(int(price_str))

                # ‚úÖ Í∏∞Î≥∏ Ï†ïÎ≥¥ Î∞òÏòÅ
                self.basic_info_map[code] = {
                    **self.basic_info_map.get(code, {}),
                    "price": price
                }

                # ‚úÖ Í¥ÄÏã¨Ï¢ÖÎ™© ÌòÑÏû¨Í∞Ä Í∞±Ïã†
                self.manager.update_real_time_price(code, price)
                update_watchlist_price(self.stock_search_table, self.basic_info_map, code, price)

                # ‚úÖ Ï°∞Í±¥Í≤ÄÏÉâ ÌÖåÏù¥Î∏î Í∞±Ïã† (Ï°∞Í±¥Í≤ÄÏÉâ Í≤∞Í≥ºÏóê Ìè¨Ìï®Îêú Ï¢ÖÎ™©Îßå)
                for row in range(self.condition_table.rowCount()):
                    item_code = self.condition_table.item(row, 0)
                    item_prev = self.condition_table.item(row, 2)
                    if item_code and item_code.text() == code and item_prev:
                        try:
                            prev = int(item_prev.text().replace(",", ""))
                            rate = ((price - prev) / prev * 100) if prev else 0.0

                            self.condition_table.setItem(row, 3, QTableWidgetItem(f"{price:,}"))  # ÌòÑÏû¨Í∞Ä
                            rate_item = QTableWidgetItem(f"{rate:.2f}%")
                            rate_item.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
                            if rate > 0:
                                rate_item.setForeground(Qt.red)
                            elif rate < 0:
                                rate_item.setForeground(Qt.blue)
                            self.condition_table.setItem(row, 4, rate_item)
                        except Exception as e:
                            log(self.log_box, f"‚ö†Ô∏è Ï°∞Í±¥Í≤ÄÏÉâ ÌÖåÏù¥Î∏î Í∞±Ïã† Ïã§Ìå®: {code} / {e}")
                        break  # Ï°∞Í±¥Í≤ÄÏÉâ ÌÖåÏù¥Î∏îÏóêÏÑú Ìï¥Îãπ Ï¢ÖÎ™©Îßå ÏóÖÎç∞Ïù¥Ìä∏

                # ‚úÖ ÏûêÎèôÎß§Îß§Í∞Ä ÏºúÏßÑ Í≤ΩÏö∞Îßå ÌèâÍ∞Ä
                if self.executor.enabled:
                    self.executor.evaluate_buy(code, price)
                    self.executor.evaluate_sell(code, price)

            except Exception as e:
                log(self.log_box, f"‚ùå ÌòÑÏû¨Í∞Ä Î≥ÄÌôò Ïã§Ìå®: {code} ‚Üí '{price_str}' / {e}")

    def handle_tr_data(self, scr_no, rq_name, tr_code, record_name, prev_next):
        if rq_name.startswith("Í∏∞Î≥∏Ï†ïÎ≥¥_"):
            handle_watchlist_tr_data(self.api, self.stock_search_table, self.basic_info_map, rq_name, tr_code)
        else:
            self.manager.handle_tr_data(scr_no, rq_name, tr_code, record_name, prev_next)

    def is_market_closed(self):
        now = datetime.datetime.now()
        weekday = now.weekday()
        hour = now.hour
        minute = now.minute
        return weekday >= 5 or (hour > 15 or (hour == 15 and minute >= 30))
                   
    def manual_buy_clicked(self, code):
        account = self.executor.get_account_by_step(1)  # Í≥ÑÏ¢å1

        # ‚úÖ buy_settings
        buy_conf = self.executor.buy_settings.get("accounts", {}).get("Í≥ÑÏ¢å1", {})
        amount = buy_conf.get("amount", 0)

        # ‚úÖ ÏßÄÏ†ïÍ∞Ä ÏÇ¨Ïö©
        order_type_ui = "ÏßÄÏ†ïÍ∞Ä"
        s_order_type = 1
        s_hoga = "00"

        # ‚úÖ ÌòÑÏû¨Í∞Ä Î∞è Ï¢ÖÎ™©Î™Ö
        info = self.basic_info_map.get(code, {})
        current_price = info.get("price") or info.get("current_price", 0)
        name = info.get("name", code)

        log_debug(self.log_box, f"[üõ† ÏàòÎèôÎß§Ïàò ÏßÑÏûÖ] {code} / ÌòÑÏû¨Í∞Ä: {current_price}, Í∏àÏï°: {amount}, Ïù¥Î¶Ñ: {name}")

        if current_price == 0:
            log(self.log_box, f"‚ùå {code} Îß§Ïàò Ïã§Ìå®: ÌòÑÏû¨Í∞Ä ÏóÜÏùå (TR ÎØ∏ÎèÑÎã¨ ÎòêÎäî Ïã§ÏãúÍ∞Ñ ÎØ∏Î∞òÏòÅ)")
            return
        if amount == 0:
            log(self.log_box, f"‚ùå {code} Îß§Ïàò Ïã§Ìå®: Ï†ÑÎûµ ÏÑ§Ï†ï Í∏àÏï° ÏóÜÏùå")
            return

        confirm = QMessageBox.question(
            self.window(),  # Î™ÖÌôïÌïú parent ÏÑ§Ï†ï
            "Îß§Ïàò ÌôïÏù∏",
            f"[{code} - {name}]\nÌòÑÏû¨Í∞Ä {current_price:,}ÏõêÏóê\n{amount:,}Ïõê **ÏßÄÏ†ïÍ∞Ä** Îß§Ïàò ÏßÑÌñâÌï†ÍπåÏöî?",
            QMessageBox.Yes | QMessageBox.No,
        )

        if confirm == QMessageBox.Yes:
            qty = max(int(amount // current_price), 1)
            s_rqname = f"ÏàòÎèôÎß§Ïàò:{code}"
            s_screen = "9999"
            s_account = account
            s_price = int(current_price)

            if SHOW_DEBUG:
                log_debug(self.log_box, f"üì° SendOrder Ìò∏Ï∂úÎê®:\n"
                                        f"  üìÑ rqname      = {s_rqname}\n"
                                        f"  üñ• screen_no   = {s_screen}\n"
                                        f"  üí≥ acc_no      = {s_account}\n"
                                        f"  üîÅ order_type  = {s_order_type} (1: ÏßÄÏ†ïÍ∞Ä)\n"
                                        f"  üßæ code        = {code}\n"
                                        f"  üî¢ qty         = {qty}\n"
                                        f"  üí∞ price       = {s_price}\n"
                                        f"  üéØ hoga        = {s_hoga}")

            res = self.api.send_order(
                rqname=s_rqname,
                screen_no=s_screen,
                acc_no=s_account,
                order_type=s_order_type,
                code=code,
                qty=qty,
                price=s_price,
                hoga=s_hoga,
                org_order_no=""
            )

            self.executor.pending_buys.add((code, account))
            log(self.log_box, f"üõí ÏàòÎèôÎß§Ïàò: {code} | {qty}Ï£º | ÏßÄÏ†ïÍ∞Ä | Í≥ÑÏ¢å: {s_account}")

            # ‚úÖ ÏÉÅÌÉú Í∞±Ïã†
            if hasattr(self, "stock_search_table"):
                update_watchlist_status(self.stock_search_table, code, "‚è≥ Ï≤¥Í≤∞ ÎåÄÍ∏∞")

            # ‚úÖ ÏûîÍ≥† Í∞±Ïã† ÏöîÏ≤≠
            if hasattr(self.manager, "request_holdings"):
                self.manager.request_holdings(s_account)

    def handle_strategy_selected(self, strategy_name):
        strategy = load_strategy(strategy_name, self.log_box)  # ‚úÖ Î°úÍ∑∏ Ï∂úÎ†• Ï∂îÍ∞Ä
        if not strategy:
            return
        self.strategy_name_input.setText(strategy_name)

        self.set_buy_settings_to_ui(strategy["buy"])
        self.set_sell_settings_to_ui(strategy["sell"])

        # ‚úÖ executorÍ∞Ä Ï°¥Ïû¨Ìï† ÎïåÎßå ÏÑ§Ï†ï ÏóÖÎç∞Ïù¥Ìä∏
        if hasattr(self, "executor") and self.executor:
            self.executor.update_settings(strategy)
            self.executor.test_mode = strategy.get("buy", {}).get("test_mode", False)  # ‚úÖ Ï∂îÍ∞Ä
        else:
            log(self.log_box, "‚ö†Ô∏è ÏûêÎèôÎß§Îß§ Ïã§ÌñâÍ∏∞Í∞Ä ÏïÑÏßÅ Ï¥àÍ∏∞ÌôîÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.")


    def handle_save_strategy(self):
        strategy_name = self.strategy_name_input.text().strip()
        if not strategy_name:
            log(self.log_box, "‚ùå Ï†ÑÎûµ Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî.")
            return

        # Îß§Ïàò ÏÑ§Ï†ï Ï∂îÏ∂ú
        buy_settings = {
            "order_type": self.buy_order_type_combo.currentText(),
            "test_mode": self.buy_test_mode_checkbox.isChecked(),
            "accounts": {}
        }

        for i, acc in enumerate(["Í≥ÑÏ¢å1", "Í≥ÑÏ¢å2", "Í≥ÑÏ¢å3", "Í≥ÑÏ¢å4"]):
            buy_settings["accounts"][acc] = {
                "enabled": self.buy_account_buttons[i].isChecked(),
                "amount": float(self.buy_amount_inputs[i].text().replace(",", "") or 0),
                "drop_rate": float(self.buy_drop_inputs[i].text() or 0)
            }

        # Îß§ÎèÑ ÏÑ§Ï†ï Ï∂îÏ∂ú
        sell_settings = {
            "order_type": self.sell_order_type_combo.currentText(),
            "accounts": {}
        }

        for i, acc in enumerate(["Í≥ÑÏ¢å1", "Í≥ÑÏ¢å2", "Í≥ÑÏ¢å3", "Í≥ÑÏ¢å4"]):
            sell_settings["accounts"][acc] = {
                "enabled": self.sell_account_buttons[i].isChecked(),
                "ratio": float(self.sell_ratio_inputs[i].text() or 0),
                "profit_rate": float(self.sell_profit_inputs[i].text() or 0)
            }

        # Ï†ÑÎûµ Ï†ÄÏû•
        save_current_strategy(strategy_name, buy_settings, sell_settings)

        # ÎìúÎ°≠Îã§Ïö¥Ïóê Ï†ÑÎûµ ÏóÜÏúºÎ©¥ Ï∂îÍ∞Ä
        existing = [self.strategy_dropdown.itemText(i) for i in range(self.strategy_dropdown.count())]
        if strategy_name not in existing:
            self.strategy_dropdown.addItem(strategy_name)

        log(self.log_box, f"‚úÖ Ï†ÑÎûµ '{strategy_name}' Ï†ÄÏû• ÏôÑÎ£å")

        # ‚úÖ Ï†ÄÏû•Ìïú Ï†ÑÎûµÏùÑ ÌòÑÏû¨ ÏûêÎèôÎß§Îß§Ïóê Ï¶âÏãú Î∞òÏòÅ
        if hasattr(self, 'executor'):
            self.executor.update_settings({
                "buy": buy_settings,
                "sell": sell_settings
            })
            self.executor.test_mode = buy_settings.get("test_mode", False)
            log(self.log_box, f"üîÅ Ï†ÑÎûµ '{strategy_name}' ÏûêÎèôÎß§Îß§Ïóê Ï¶âÏãú Î∞òÏòÅÎê®")
            
    def load_existing_strategies(self):
        strategy_dir = "strategies"
        if not os.path.exists(strategy_dir):
            return

        for file in os.listdir(strategy_dir):
            if file.endswith(".json"):
                name = file.replace(".json", "")
                if self.strategy_dropdown.findText(name) == -1:
                    self.strategy_dropdown.addItem(name)
                  
    def handle_delete_strategy(self):
        strategy_name = self.strategy_dropdown.currentText().strip()
        if not strategy_name:
            log(self.log_box, "‚ùå ÏÇ≠Ï†úÌï† Ï†ÑÎûµÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.")
            return

        if delete_strategy(strategy_name):
            # ÎìúÎ°≠Îã§Ïö¥ÏóêÏÑú Ï†úÍ±∞
            index = self.strategy_dropdown.findText(strategy_name)
            if index >= 0:
                self.strategy_dropdown.removeItem(index)

            # ÏûÖÎ†• ÌïÑÎìú ÎπÑÏö∞Í∏∞
            self.strategy_name_input.setText("")
            log(self.log_box, f"üóë Ï†ÑÎûµ '{strategy_name}' ÏÇ≠Ï†úÎê®")
        else:
            log(self.log_box, f"‚ö†Ô∏è Ï†ÑÎûµ '{strategy_name}' ÏÇ≠Ï†ú Ïã§Ìå®")

    def show_all_holdings_popup(self):
        if not hasattr(self, 'accounts') or not self.accounts:
            log(self.log_box, "‚ùó Î°úÍ∑∏Ïù∏ ÌõÑ Ïù¥Ïö© Í∞ÄÎä•Ìï©ÎãàÎã§.")
            return

        # ‚úÖ holdings ÏöîÏ≤≠ ÏôÑÎ£å ÌõÑ Ï∞Ω ÏÉùÏÑ±
        def after_loaded():
            self.all_holdings_popup = AllHoldingsPopup(self.manager.holdings, self.executor.basic_info_map, self.manager)
            self.all_holdings_popup.setWindowModality(Qt.NonModal)
            self.all_holdings_popup.setWindowFlags(Qt.Window)
            self.all_holdings_popup.show()

            self.all_holdings_popup.finished.connect(lambda: self.holdings_refresh_timer.stop())

            self.holdings_refresh_timer = QTimer(self)
            self.holdings_refresh_timer.timeout.connect(lambda: self.all_holdings_popup.refresh())
            self.holdings_refresh_timer.start(1500)

        self.manager.request_all_holdings(self.accounts, on_complete=after_loaded)

    def update_clock(self):
        now = QDateTime.currentDateTime()
        day_of_week = ["Ïùº", "Ïõî", "Ìôî", "Ïàò", "Î™©", "Í∏à", "ÌÜ†"][now.date().dayOfWeek() % 7]
        time_str = now.toString(f"MM-dd({day_of_week}) HH:mm:ss")
        self.clock_label.setText(time_str)
        
    def check_schedule_and_apply(self):
        if not self.executor.enabled:
            return

        if not self.schedule_enabled_button.isChecked():
            return

        config = getattr(self, "schedule_config", None)
        if not config or not config.get("enabled"):
            return

        start_time = QTime.fromString(config.get("start_time", "09:00"), "HH:mm")
        end_time = QTime.fromString(config.get("end_time", "15:20"), "HH:mm")
        now = QTime.currentTime()

        # ‚úÖ Îß§Îß§ ÏãúÏûë/Ï¢ÖÎ£å ÏãúÍ∞ÑÏóê Îî∞Î•∏ ÏûêÎèô Ï†úÏñ¥
        if start_time <= now < end_time:
            if not self.executor.enabled:
                self.handle_trade_start()
        else:
            if self.executor.enabled:
                self.handle_trade_stop()
            return  # Í±∞ÎûòÏãúÍ∞Ñ Ïô∏ÏóêÎäî Íµ¨Í∞Ñ Ï†ÅÏö©ÎèÑ Ïä§ÌÇµ

        # ‚úÖ Íµ¨Í∞Ñ Ï†ÑÎûµ/Ï°∞Í±¥ Ï†ÅÏö© (ÌòÑÏû¨ ÏãúÍ∞ÑÏóê Ìï¥ÎãπÌïòÎäî Íµ¨Í∞Ñ 1Í∞úÎßå Ïã§Ìñâ)
        blocks = [b for b in config.get("blocks", []) if b.get("enabled")]
        for i in range(len(blocks)):
            curr = blocks[i]
            curr_time = QTime.fromString(curr.get("time", "00:00"), "HH:mm")
            next_time = QTime.fromString(blocks[i+1].get("time", "23:59"), "HH:mm") if i + 1 < len(blocks) else end_time

            if curr_time <= now < next_time:
                # ‚úÖ Ï†ÑÎûµ ÏûêÎèô Î≥ÄÍ≤Ω (UI + Ïã§ÌñâÍ∏∞ Î™®Îëê Î∞òÏòÅ)
                target_strategy = curr.get("strategy", "").strip()
                if target_strategy and target_strategy != self.strategy_dropdown.currentText():
                    self.strategy_dropdown.setCurrentText(target_strategy)
                    self.handle_strategy_selected(target_strategy)  # ‚úÖ Ï†ÑÎûµ Ï†ÅÏö©
                    log(self.log_box, f"üß† Ï†ÑÎûµ ÏûêÎèô Î≥ÄÍ≤Ω: {target_strategy}")

                # ‚úÖ Ï°∞Í±¥Í≤ÄÏÉâ ÏûêÎèô Ïã§Ìñâ
                condition = curr.get("condition", "")
                if condition and ":" in condition:
                    try:
                        index, name = condition.split(":")
                        index = int(index.strip())
                        name = name.strip()

                        self.condition_dropdown.setCurrentText(f"{index}: {name}")

                        self.api.ocx.dynamicCall(
                            "SendCondition(QString, QString, int, int)",
                            SCR_REALTIME_CONDITION, name, index, 1
                        )
                        log(self.log_box, f"üîç Ï°∞Í±¥Í≤ÄÏÉâ ÏûêÎèô Ïã§Ìñâ: {name}")
                    except Exception as e:
                        log(self.log_box, f"‚ùå Ï°∞Í±¥Í≤ÄÏÉâ Ïã§Ìñâ Ïã§Ìå®: {e}")

                break  # ‚úÖ ÌòÑÏû¨ Íµ¨Í∞ÑÎßå Ïã§Ìñâ

    def open_schedule_settings(self):
        strategy_list = [self.strategy_dropdown.itemText(i) for i in range(self.strategy_dropdown.count())]
        condition_list = [self.condition_dropdown.itemText(i) for i in range(self.condition_dropdown.count())]

        dialog = ScheduleSettingsDialog(strategy_list, condition_list, self.schedule_config if hasattr(self, "schedule_config") else None, self)

        current_schedule_name = self.schedule_dropdown_main.currentText()
        if current_schedule_name:
            dialog.set_selected_schedule(current_schedule_name)

        if dialog.exec_() == QDialog.Accepted:
            self.schedule_config = dialog.get_schedule_data()

            # ‚úÖ Ï†ÄÏû•Îêú Ïù¥Î¶Ñ Ï†ÅÏö©
            if hasattr(dialog, "last_saved_name") and dialog.last_saved_name:
                name = dialog.last_saved_name
                self.refresh_schedule_dropdown_main(selected_name=name)
                log(self.log_box, f"‚úÖ Ïä§ÏºÄÏ§Ñ '{name}' ÏÑ§Ï†ïÏù¥ Ï†ÅÏö©Îê®")
            else:
                log(self.log_box, f"‚úÖ Ïä§ÏºÄÏ§Ñ ÏÑ§Ï†ïÏù¥ Ï†ÅÏö©Îê®")
            
    def setup_menu_actions(self):
        self.actionOpenScheduleDialog = self.findChild(QAction, "actionOpenScheduleDialog")
        if self.actionOpenScheduleDialog:
            self.actionOpenScheduleDialog.triggered.connect(self.open_schedule_settings)

        self.actionOpenConfigDialog = self.findChild(QAction, "actionOpenConfigDialog")
        if self.actionOpenConfigDialog:
            self.actionOpenConfigDialog.triggered.connect(self.open_config_dialog)
         
    def refresh_schedule_dropdown_main(self, selected_name=None):
        if not hasattr(self, "schedule_dropdown_main"):
            return

        self.schedule_dropdown_main.blockSignals(True)
        self.schedule_dropdown_main.clear()

        if os.path.exists("schedules"):
            names = [f[:-5] for f in os.listdir("schedules") if f.endswith(".json")]
            self.schedule_dropdown_main.addItems(sorted(names))

            if selected_name and selected_name in names:
                self.schedule_dropdown_main.setCurrentText(selected_name)

        self.schedule_dropdown_main.blockSignals(False)

    def load_selected_schedule(self, name):
        path = f"schedules/{name}.json"
        if not os.path.exists(path):
            return
        with open(path, "r", encoding="utf-8") as f:
            config = json.load(f)

        self.schedule_config = config

        # ‚úîÔ∏è Ï†ÅÏö© Ïó¨Î∂Ä ÌåêÎã®Ìï¥ÏÑú Î°úÍ∑∏ Î∂ÑÍ∏∞
        if getattr(self, "schedule_enabled_button", None) and self.schedule_enabled_button.isChecked():
            log(self.log_box, f"‚úÖ Ïä§ÏºÄÏ§Ñ '{name}' Î°úÎìúÎê® Î∞è Ï†ÅÏö© Ï§ÄÎπÑÎê®: {self.schedule_config}")
        else:
            log(self.log_box, f"üìÇ Ïä§ÏºÄÏ§Ñ '{name}' Î∂àÎü¨Ïò¥ (Ï†ÅÏö©ÏùÄ Ïä§ÏºÄÏ§Ñ ÌÜ†Í∏Ä ON Ïãú Ïã§ÌñâÎê®)")

    def on_schedule_toggle(self, checked):
        if checked:
            name = self.schedule_dropdown_main.currentText()
            self.load_selected_schedule(name)
            config = getattr(self, "schedule_config", None)
            if config:
                self.check_schedule_and_apply()
                log(self.log_box, f"‚úÖ Ïä§ÏºÄÏ§Ñ '{name}' ÏÑ†ÌÉùÎê® ‚Üí ÏûêÎèôÎß§Îß§Ïóê Ï†ÅÏö© ÏôÑÎ£åÎê®")
            else:
                log(self.log_box, f"‚ö†Ô∏è Ïä§ÏºÄÏ§Ñ '{name}'ÏùÑ Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.")
        else:
            log(self.log_box, "üõë Ïä§ÏºÄÏ§Ñ Ï†ÅÏö© Ìï¥Ï†úÎê®")

    def toggle_condition_auto_buy(self, checked):
        if hasattr(self.executor, "condition_auto_buy"):
            self.executor.condition_auto_buy = checked
            status = "‚úÖ Ï°∞Í±¥Í≤ÄÏÉâ ÏûêÎèôÎß§Ïàò ÌôúÏÑ±ÌôîÎê®" if checked else "üõë Ï°∞Í±¥Í≤ÄÏÉâ ÏûêÎèôÎß§Ïàò ÎπÑÌôúÏÑ±ÌôîÎê®"
            log(self.log_box, status)
        else:
            log(self.log_box, "‚ö†Ô∏è ExecutorÍ∞Ä Ï¥àÍ∏∞ÌôîÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.")

    def open_config_dialog(self, first_time=False):
        dialog = ConfigDialog(self.config, self)
        if dialog.exec_() != QDialog.Accepted:
            return  # ÏÇ¨Ïö©ÏûêÍ∞Ä Ï∑®ÏÜåÌïú Í≤ΩÏö∞ ÏïÑÎ¨¥ ÏûëÏóÖÎèÑ ÌïòÏßÄ ÏïäÏùå

        self.config = dialog.get_config()
        save_user_config(self.config)
        update_debug_flags(self.config)
        log(self.log_box, "‚úÖ ÏÑ§Ï†ï Ï†ÄÏû• ÏôÑÎ£å")

        self.executor.set_accounts([
            self.config.get("account1", ""),
            self.config.get("account2", ""),
            self.config.get("account3", ""),
            self.config.get("account4", ""),
        ])

        # ÌÖîÎ†àÍ∑∏Îû® ÏÑ§Ï†ï Ï†ÅÏö©
        token = self.config.get("telegram_token")
        chat_id = self.config.get("telegram_chat_id")
        if token and chat_id:
            configure_telegram(token, chat_id)
            log(self.log_box, "‚úÖ ÌÖîÎ†àÍ∑∏Îû® ÏÑ§Ï†ï Ï†ÅÏö© ÏôÑÎ£å")
        else:
            log(self.log_box, "‚ö†Ô∏è ÌÖîÎ†àÍ∑∏Îû® ÏÑ§Ï†ïÏù¥ ÎπÑÏñ¥ ÏûàÏùå")

        # Íµ¨Í∏Ä ÏãúÌä∏ ÏÑ§Ï†ï Ï†ÅÏö©
        self.sheet_id = self.config.get("sheet_id")
        self.sheet_name = self.config.get("sheet_name", "Í¥ÄÏã¨Ï¢ÖÎ™©")  # Í∏∞Î≥∏Í∞í Ï†úÍ≥µ

        if self.sheet_id:
            log(self.log_box, f"üìÑ Íµ¨Í∏Ä ÏãúÌä∏ ÏÑ§Ï†ï Ï†ÅÏö© ÏôÑÎ£å ‚Üí ID: {self.sheet_id}, Ïù¥Î¶Ñ: {self.sheet_name}")
        else:
            log(self.log_box, "‚ö†Ô∏è Íµ¨Í∏Ä ÏãúÌä∏ IDÍ∞Ä ÏÑ§Ï†ïÎêòÏñ¥ ÏûàÏßÄ ÏïäÏäµÎãàÎã§.")

        if first_time:
            QMessageBox.information(self, "ÏÑ§Ï†ï ÏôÑÎ£å", "‚úÖ ÏÑ§Ï†ïÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§. ÌîÑÎ°úÍ∑∏Îû®ÏùÑ ÏãúÏûëÌï† Ïàò ÏûàÏäµÎãàÎã§.")
        else:
            QMessageBox.information(self, "ÏÑ§Ï†ï Ï†ÅÏö©Îê®", "‚úÖ ÏÑ§Ï†ïÏù¥ Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.\nÌîÑÎ°úÍ∑∏Îû®ÏùÑ Ïû¨ÏãúÏûëÌïòÎ©¥ ÎîîÎ≤ÑÍ∑∏ Î™®ÎìúÍ∞Ä Ï†ÅÏö©Îê©ÎãàÎã§.")

__all__ = ["AutoTradeUI"]
