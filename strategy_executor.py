from datetime import datetime
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtWidgets import QTableWidgetItem
from modules.telegram_utils import send_telegram_message
from modules.google_writer import append_trade_log
from utils import write_trade_log_file
from utils import (
    log_debug,
    log_info,
    log_trade,
    SHOW_DEBUG,
    SHOW_VERBOSE_BUY_EVAL,
    SHOW_VERBOSE_SELL_EVAL
)

class AutoTradeExecutor:
    def __init__(self, api):
        self.api = api
        self.accounts = []
        self.account_settings = {}
        self.buy_settings = {}
        self.sell_settings = {}
        self.holdings = {}
        self.executed_orders = {}
        self.buy_history = {}
        self.sell_history = {}
        self.pending_buys = set()
        self.enabled = False
        self.basic_info_map = {} 
        self.test_mode = False
        self.condition_auto_buy = False

    def set_accounts(self, accounts):
        self.accounts = accounts

    def set_basic_info_map(self, info_map):
        self.basic_info_map = info_map

    def update_settings(self, strategy):
        self.account_settings = strategy
        self.buy_settings = strategy.get("buy", {})
        self.sell_settings = strategy.get("sell", {})
        
            # üîΩ Ïó¨Í∏∞Ïóê Ï∂îÍ∞Ä
        if hasattr(strategy, "name"):
            self.current_strategy_name = strategy["name"]
        elif hasattr(self, "manager") and hasattr(self.manager.ui, "strategy_dropdown"):
            self.current_strategy_name = self.manager.ui.strategy_dropdown.currentText()
        else:
            self.current_strategy_name = "Ï†ÑÎûµÎØ∏ÏßÄÏ†ï"

    def record_holding(self, code, account, qty, price):
        self.holdings.setdefault(code, {})[account] = {"buy_price": price, "qty": qty}


    def clear_holding(self, code, account):
        if code in self.holdings and account in self.holdings[code]:
            del self.holdings[code][account]

    def get_previous_close(self, code):
        return self.basic_info_map.get(code, {}).get("prev_price", 10000)

    def get_account_by_step(self, step):
        if 1 <= step <= len(self.accounts):
            return self.accounts[step - 1]
        return ""
    def evaluate_buy(self, code, current_price):
        if not self.enabled:
            log_debug(None, f"[‚è∏ Îß§Ïàò ÌèâÍ∞Ä Ï§ëÎã®] ÏûêÎèôÎß§Îß§ ÎπÑÌôúÏÑ±Ìôî ÏÉÅÌÉú")
            return

        if code.startswith("A"):
            code = code[1:]

        if SHOW_VERBOSE_BUY_EVAL:
            log_debug(None, f"[üëÅ Îß§ÏàòÌèâÍ∞Ä ÏßÑÏûÖ] {code} / ÌòÑÏû¨Í∞Ä: {current_price}")

        # ‚úÖ Í≥ÑÏ¢å 1~4 ÏàúÏÑúÎåÄÎ°ú ÌèâÍ∞Ä
        for step in range(1, 5):
            account_no = self.get_account_by_step(step)
            acc_conf = self.buy_settings["accounts"].get(f"Í≥ÑÏ¢å{step}", {})
            if not self.can_buy(code, account_no, acc_conf, step, current_price):
                continue

            amount = acc_conf.get("amount", 0)
            order_type = self.buy_settings.get("order_type", "ÏãúÏû•Í∞Ä")
            self.send_buy_order(code, account_no, current_price, amount, order_type, step)
            break  # ‚úÖ Ìïú Í≥ÑÏ¢åÎßå Îß§Ïàò ÌõÑ Ï¢ÖÎ£å (Îã§Ï§ëÎß§Ïàò Î∞©ÏßÄ)
        
        
    def can_buy(self, code, account_no, acc_conf, step, current_price):
        if (code, account_no) in self.pending_buys:
            self.log_once(f"[‚õî Ï≤¥Í≤∞ÎåÄÍ∏∞] {code} / Í≥ÑÏ¢å={account_no} ‚Üí ÏÉùÎûµ")
            return False

        if self.holdings.get(code, {}).get(account_no, {}).get("qty", 0) > 0:
            self.log_once(f"[‚õî Ï§ëÎ≥µÎ≥¥Ïú†] {code}Îäî Í≥ÑÏ¢å {account_no}ÏóêÏÑú Ïù¥ÎØ∏ Î≥¥Ïú† Ï§ë ‚Üí ÏÉùÎûµ")
            return False

        if not acc_conf.get("enabled", False):
            self.log_once(f"[‚ö†Ô∏è ÎπÑÌôúÏÑ±] Í≥ÑÏ¢å {account_no} Îß§Ïàò ÎπÑÌôúÏÑ±ÌôîÎê® ‚Üí ÏÉùÎûµ")
            return False

        drop_rate = acc_conf.get("drop_rate", 0)

        # ‚úÖ ÏÑ†Ìñâ Îß§Ïàò Í∞ÄÍ≤© Í∞ÄÏ†∏Ïò§Í∏∞ (Í≥ÑÏ¢å1ÏùÄ Í∏∞Ï§ÄÍ∞ÄÎ•º prev_price = Ï†ÑÏùºÏ¢ÖÍ∞Ä ÏÇ¨Ïö©)
        if step == 1:
            prev_price = self.get_previous_close(code)
        else:
            prev_account = self.get_account_by_step(step - 1)
            prev_price = self.buy_history.get((code, prev_account), {}).get("price")

        if prev_price and current_price > 0:
            rate = (prev_price - current_price) / prev_price * 100
            if rate < drop_rate:
                self.log_once(f"[‚è¨ ÌïòÎùΩÎ•† ÎØ∏Îã¨] {code} ÌòÑÏû¨: {current_price}, Í∏∞Ï§ÄÎåÄÎπÑ {rate:.2f}% < {drop_rate}% ‚Üí ÏÉùÎûµ")
                return False
        else:
            self.log_once(f"[‚ùå Í∏∞Ï§Ä Í∞ÄÍ≤© ÏóÜÏùå] {code} ‚Üí ÏÉùÎûµ")
            return False

        return True

    
    
    def send_buy_order(self, code, account_no, current_price, amount, order_type, step):
        if amount <= 0 or current_price <= 0:
            self.log_once(f"[‚ùå Îß§ÏàòÎ∂àÍ∞Ä] ÏûòÎ™ªÎêú Í∏àÏï° ÎòêÎäî Í∞ÄÍ≤© ({amount} / {current_price})")
            return

        if self.test_mode:
            qty = 1
            price = 0 if order_type == "ÏãúÏû•Í∞Ä" else current_price
            self.api.send_order(f"Îß§Ïàò_TEST_{code}", "1000", account_no, 1, code, qty, price, order_type, "")
            self.pending_buys.add((code, account_no))
            self.log_once(f"[üß™ 1Ï£º Îß§Ïàò ÌÖåÏä§Ìä∏] {code} / Í≥ÑÏ¢å: {account_no}")
            return

        qty = int(amount / current_price)
        if qty <= 0:
            self.log_once(f"[‚ùå Îß§ÏàòÎ∂àÍ∞Ä] Í∏àÏï° {amount}ÏúºÎ°ú Îß§Ïàò ÏàòÎüâ Î∂ÄÏ°± ‚Üí ÏÉùÎûµ")
            return

        price = 0 if order_type == "ÏãúÏû•Í∞Ä" else current_price
        screen_no = self.get_screen_no_by_account(account_no)
        order_id = f"Îß§Ïàò_{code}_{account_no}_{step}"

        self.api.send_order(order_id, screen_no, account_no, 1, code, qty, price, order_type, "")
        self.pending_buys.add((code, account_no))

        self.log_once(f"[üì§ Îß§ÏàòÏ£ºÎ¨∏ Ï†ÑÏÜ°] {code} / Í≥ÑÏ¢å: {account_no} / ÏàòÎüâ: {qty} / Í∞ÄÍ≤©: {price} / Î∞©Ïãù: {order_type}")

        # Í∏∞Î°ùÏö© Ï†ïÎ≥¥ Ï†ÄÏû•
        self.buy_history[(code, account_no)] = {
            "step": step,
            "price": current_price,
            "strategy": self.current_strategy_name
        }


    def evaluate_sell(self, code, current_price):
        # print(f"[Îß§ÎèÑ ÌèâÍ∞Ä ÏãúÎèÑ] {code} / ÌòÑÏû¨Í∞Ä: {current_price}")
        if not self.enabled:
            log_debug(None, f"[‚è∏ Îß§ÎèÑ ÌèâÍ∞Ä Ï§ëÎã®] ÏûêÎèôÎß§Îß§ ÎπÑÌôúÏÑ±Ìôî ÏÉÅÌÉú")
            return

        if code.startswith("A"):
            code = code[1:]

        if SHOW_VERBOSE_SELL_EVAL:
            log_debug(None, f"[üëÅ Îß§ÎèÑÌèâÍ∞Ä ÏßÑÏûÖ] {code} / ÌòÑÏû¨Í∞Ä: {current_price}")

        if code not in self.holdings:
            self.log_once(f"[‚ùå Î≥¥Ïú†Ï†ïÎ≥¥ ÏóÜÏùå] {code}")
            return

        for i, account in enumerate(self.accounts):
            # print(f" - Í≥ÑÏ¢å Í≤ÄÏÇ¨: {account} / Î≥¥Ïú† Ïó¨Î∂Ä: {account in self.holdings.get(code, {})}")
            holding = self.holdings[code].get(account)
            if not holding:
                self.log_once(f"[‚õî Ìï¥Îãπ Í≥ÑÏ¢å Î≥¥Ïú† ÏóÜÏùå] {code} / Í≥ÑÏ¢å: {account}")
                continue

            step = i + 1
            acc = f"Í≥ÑÏ¢å{step}"
            acc_conf = self.sell_settings.get("accounts", {}).get(acc)

            if not acc_conf:
                log_debug(None, f"[‚ö†Ô∏è Îß§ÎèÑ ÏÑ§Ï†ï ÏóÜÏùå] {code} / {acc}")
                continue
            if not acc_conf.get("enabled"):
                log_debug(None, f"[üö´ Îß§ÎèÑ ÏÑ§Ï†ï ÎπÑÌôúÏÑ±Ìôî] {code} / {acc}")
                continue

            buy_price = holding.get("buy_price", 0)
            qty = holding.get("qty", 0)
            # print(f"[üì¶ Î≥¥Ïú†Ï†ïÎ≥¥] {code} / Í≥ÑÏ¢å:{account} / qty={qty}, buy_price={buy_price}")
            
            if qty <= 0:
                log_debug(None, f"[üì¶ Îß§ÎèÑ Î∂àÍ∞Ä: ÏàòÎüâ ÏóÜÏùå] {code} / Í≥ÑÏ¢å: {account}")
                continue
            
            # ‚úÖ buy_priceÍ∞Ä 0 Ïù¥ÌïòÏù∏ Í≤ΩÏö∞ Îß§ÎèÑ ÌèâÍ∞Ä ÏÉùÎûµ
            if buy_price <= 0:
                log_debug(None, f"[‚õî Îß§ÎèÑ ÌèâÍ∞Ä ÏÉùÎûµ] {code} / Í≥ÑÏ¢å:{account} / buy_price=0 Ïù¥Ìïò")
                continue
            # ‚úÖ Ïó¨Í∏∞Ïóê Î°úÍ∑∏ Ï∂îÍ∞Ä
            log_debug(None, f"[Í≤ÄÏÇ¨] Îß§ÎèÑ ÌèâÍ∞Ä Ï†Ñ buy_price ÌôïÏù∏: {code} / Í≥ÑÏ¢å:{account} / qty:{qty} / buy_price:{buy_price} / current_price:{current_price}")

            target_rate = acc_conf.get("profit_rate", 0)
            target_price = buy_price * (1 + target_rate / 100)

            if SHOW_VERBOSE_SELL_EVAL:
                log_debug(None, f"[‚öñÔ∏è Îß§ÎèÑ ÌèâÍ∞Ä] {code} | Í≥ÑÏ¢å:{account} | Îß§ÏàòÍ∞Ä:{buy_price} | ÌòÑÏû¨Í∞Ä:{current_price} | Î™©ÌëúÍ∞Ä:{target_price:.2f}")

            if current_price >= target_price:
                ratio = acc_conf.get("ratio", 100)
                log_info(None, f"[‚úÖ Îß§ÎèÑ Ï°∞Í±¥ ÎßåÏ°±] {code} / Í≥ÑÏ¢å:{account} / ÎπÑÏú®:{ratio}%")
                self.send_sell_order(code, ratio, account, current_price)
                self.sell_history[code] = {"step": step}
            else:
                if SHOW_VERBOSE_SELL_EVAL:
                    log_debug(None, f"[‚ùå ÎØ∏Ï∂©Ï°±] {code} / ÌòÑÏû¨Í∞Ä < Î™©ÌëúÍ∞Ä ({current_price} < {target_price:.2f})")

    

    def send_sell_order(self, code, ratio, account, current_price):
        if SHOW_DEBUG:
            log_debug(None, f"üìç send_sell_order Ìò∏Ï∂úÎê®: {code}, Í≥ÑÏ¢å={account}, ÌòÑÏû¨Í∞Ä={current_price}")

        # ‚úÖ Ï†ÑÎûµÏóêÏÑú Ï£ºÎ¨∏ Î∞©Ïãù Í∞ÄÏ†∏Ïò§Í∏∞
        order_type_ui = self.sell_settings.get("order_type", "ÏßÄÏ†ïÍ∞Ä")
        if order_type_ui == "ÏãúÏû•Í∞Ä":
            order_type = 2
            hoga_type = "03"
            price = 0  # ÏãúÏû•Í∞Ä Ï£ºÎ¨∏ÏùÄ Í∞ÄÍ≤© 0
        else:
            order_type = 2
            hoga_type = "00"
            price = int(current_price)

        holding_info = self.holdings.get(code, {}).get(account, {})
        total_qty = holding_info.get("qty", 0)

        qty = max(int(float(total_qty) * float(ratio) / 100), 1)

        if SHOW_DEBUG:
            log_debug(None, f"üßæ Îß§ÎèÑ Ï§ÄÎπÑ: Í≥ÑÏ¢å={account}, Ï¥ùÎ≥¥Ïú†={total_qty}, Îß§ÎèÑÎπÑÏú®={ratio}%, ÏàòÎüâ={qty}, Í∞ÄÍ≤©={price}")

        res = self.api.send_order(
            rqname="Îß§ÎèÑ",
            screen_no="0101",
            acc_no=account,
            order_type=order_type,
            code=code,
            qty=qty,
            price=price,
            hoga=hoga_type,
            org_order_no=""
        )

        if SHOW_DEBUG:
            log_debug(None, f"üì§ Îß§ÎèÑÏ£ºÎ¨∏ Ï†ÑÏÜ°Îê® ‚Üí Í≥ÑÏ¢å:{account} | Ï¢ÖÎ™©:{code} | ÏàòÎüâ:{qty} | Ïú†Ìòï:{order_type_ui} | Í∞ÄÍ≤©:{price} | Í≤∞Í≥º:{res}")

        if hasattr(self, "account_manager"):
            if SHOW_DEBUG:
                log_debug(None, f"üîÑ Îß§ÎèÑ ÌõÑ ÏûîÍ≥† Í∞±Ïã† ÏöîÏ≤≠ ‚Üí Í≥ÑÏ¢å: {account}")
            self.account_manager.request_holdings(account)



    def handle_chejan_data(self, gubun, item_cnt, fid_list):
        print("‚úÖ handle_chejan_data ÏßÑÏûÖ")

        if SHOW_DEBUG:
            log_debug(None, f"[üì® Chejan ÏàòÏã†] gubun={gubun}")

        if gubun != "0":
            if SHOW_DEBUG:
                log_debug(None, f"[‚õîÔ∏è Î¨¥ÏãúÎê®] gubun={gubun} (Ï≤¥Í≤∞ ÏïÑÎãå Í≤ΩÏö∞)")
            return

        raw_code = self.api.ocx.dynamicCall("GetChejanData(int)", 9001).strip()
        code = raw_code[1:] if raw_code.startswith("A") else raw_code
        order_status = self.api.ocx.dynamicCall("GetChejanData(int)", 913).strip()
        filled_qty = self.api.ocx.dynamicCall("GetChejanData(int)", 911).strip()
        price_str = self.api.ocx.dynamicCall("GetChejanData(int)", 910).strip().replace(",", "")
        account_no = self.api.ocx.dynamicCall("GetChejanData(int)", 9201).strip()
        order_type_code = self.api.ocx.dynamicCall("GetChejanData(int)", 907).strip()
        order_type_str = {
            "1": "Îß§ÎèÑ",
            "2": "Îß§Ïàò",
            "3": "Ï∑®ÏÜå",
            "4": "Ï†ïÏ†ï",
            # ÌïÑÏöîÌïòÎ©¥ Îçî Ï∂îÍ∞Ä
        }.get(order_type_code, order_type_code)


        if SHOW_DEBUG:
            log_debug(None, f"[üß™ Ï≤¥Í≤∞ ÌåêÎ≥Ñ] status={order_status}, qty={filled_qty}, order_type={order_type_str}, price={price_str}, code={code}, acc={account_no}")

        if not order_type_str or order_status != "Ï≤¥Í≤∞" or not filled_qty.isdigit():
            return

        qty = int(filled_qty)
        price = int(price_str or "0")

        now = datetime.now()
        date = now.strftime("%Y-%m-%d")
        time = now.strftime("%H:%M:%S")
        name = self.basic_info_map.get(code, {}).get("name", code)
        amount = qty * price
        fee, tax = 0, 0
        settled = amount - fee - tax
        strategy_name = getattr(self, "current_strategy_name", "Ï†ÑÎûµÎØ∏ÏßÄÏ†ï")

        row = [date, time, account_no, code, name, order_type_str, qty, price, amount, fee, tax, settled, strategy_name, ""]

        if "Îß§Ïàò" in order_type_str:
            log_info(None, f"[üü¢ Îß§Ïàò Ï≤¥Í≤∞] {code} | Í≥ÑÏ¢å: {account_no} | ÏàòÎüâ: {qty} | Í∞ÄÍ≤©: {price}")
            write_trade_log_file(f"[üü¢ Îß§Ïàò Ï≤¥Í≤∞] {code} | Í≥ÑÏ¢å: {account_no} | ÏàòÎüâ: {qty} | Í∞ÄÍ≤©: {price}")

            if hasattr(self, "pending_buys"):
                self.pending_buys.discard((code, account_no))

            account_holdings = self.holdings.setdefault(code, {})
            if account_no in account_holdings:
                prev_qty = account_holdings[account_no].get("qty", 0)
                prev_price = account_holdings[account_no].get("buy_price", 0)
                new_qty = prev_qty + qty
                new_avg_price = (prev_qty * prev_price + qty * price) // new_qty
                account_holdings[account_no] = {"buy_price": new_avg_price, "qty": new_qty}
            else:
                account_holdings[account_no] = {"buy_price": price, "qty": qty}

            # ‚úÖ executorÏóêÎèÑ Î∞òÏòÅ
            # if hasattr(self, "executor"):
            #     self.executor.record_holding(code, account_no, qty, price)

            if hasattr(self, "reconstruct_buy_history_from_holdings"):
                self.reconstruct_buy_history_from_holdings()
                self.reconstruct_sell_history_from_holdings()

            if hasattr(self, "manager"):
                self.manager.holdings = self.holdings
                self.manager.current_account = account_no
                if hasattr(self.manager, 'request_holdings'):
                    QTimer.singleShot(2000, lambda: self.manager.request_holdings(account_no))

            if code in self.sell_history:
                if SHOW_DEBUG:
                    log_debug(None, f"[üßπ Ïû¨Îß§Ïàò Í∞êÏßÄ ‚Üí sell_history Ï†ïÎ¶¨] {code}")
                self.sell_history.pop(code)

            msg = (
                f"[üü¢ Îß§Ïàò Ï≤¥Í≤∞]\n"
                f"üìå Ï¢ÖÎ™©: {code} ({name})\n"
                f"üìÜ ÏãúÍ∞Ñ: {time}\n"
                f"üí∞ ÏàòÎüâ: {qty}Ï£º @ {price:,}Ïõê\n"
                f"üìä Ï≤¥Í≤∞Í∏àÏï°: {amount:,}Ïõê\n"
                f"üßæ Ïã§ÌòÑÍ∏àÏï°: {settled:,}Ïõê\n"
                f"üéØ Ï†ÑÎûµ: {strategy_name}\n"
                f"üè¶ Í≥ÑÏ¢å: {account_no}"
            )
            print("üì® ÌÖîÎ†àÍ∑∏Îû® Î©îÏãúÏßÄ Ï†ÑÏÜ° ÏãúÎèÑ:", msg[:30])
            send_telegram_message(msg)

        elif any(k in order_type_str for k in ["Îß§ÎèÑ", "ÌòÑÍ∏àÎß§ÎèÑ", "Ïã†Ïö©Îß§ÎèÑ"]):
            log_info(None, f"[üî¥ Îß§ÎèÑ Ï≤¥Í≤∞] {code} | Í≥ÑÏ¢å: {account_no} | ÏàòÎüâ: {qty} | Í∞ÄÍ≤©: {price}")
            write_trade_log_file(f"[üî¥ Îß§ÎèÑ Ï≤¥Í≤∞] {code} | Í≥ÑÏ¢å: {account_no} | ÏàòÎüâ: {qty} | Í∞ÄÍ≤©: {price}")

            holdings_targets = [self.holdings]
            if hasattr(self.manager, 'holdings'):
                holdings_targets.append(self.manager.holdings)

            for h in holdings_targets:
                if code in h and account_no in h[code]:
                    prev_qty = h[code][account_no].get("qty", 0)
                    new_qty = max(0, prev_qty - qty)
                    h[code][account_no]["qty"] = new_qty
                    log_debug(None, f"[üìâ Îß§ÎèÑ ÌõÑ ÏûîÍ≥† ÏàòÏ†ï] {code} / Í≥ÑÏ¢å: {account_no} / ÏûîÏó¨ÏàòÎüâ: {new_qty}")
                    if new_qty == 0:
                        log_debug(None, f"[üßπ ÏûîÍ≥†ÏóêÏÑú Ï†úÍ±∞Îê®] {code} / Í≥ÑÏ¢å: {account_no}")
                        del h[code][account_no]
                        if not h[code]:
                            del h[code]

            self.sell_history[code] = {"price": price, "time": now}
            self.buy_history.pop(code, None)

            if hasattr(self.manager, 'request_today_profit'):
                self.manager.request_today_profit(account_no)
            if hasattr(self.manager, 'request_holdings'):
                QTimer.singleShot(2000, lambda: self.manager.request_holdings(account_no))
            if hasattr(self.manager, "ui") and hasattr(self.manager.ui, "account_combo"):
                combo = self.manager.ui.account_combo
                idx = combo.findText(account_no)
                if idx != -1:
                    combo.setCurrentIndex(idx)
            if hasattr(self.manager, 'refresh_holdings_ui'):
                QTimer.singleShot(500, self.manager.refresh_holdings_ui)
                QTimer.singleShot(1500, self.manager.refresh_holdings_ui)
                QTimer.singleShot(3000, self.manager.refresh_holdings_ui)

            msg = (
                f"[üî¥ Îß§ÎèÑ Ï≤¥Í≤∞]\n"
                f"üìå Ï¢ÖÎ™©: {code} ({name})\n"
                f"üìÜ ÏãúÍ∞Ñ: {time}\n"
                f"üí∞ ÏàòÎüâ: {qty}Ï£º @ {price:,}Ïõê\n"
                f"üìä Ï≤¥Í≤∞Í∏àÏï°: {amount:,}Ïõê\n"
                f"üßæ Ïã§ÌòÑÍ∏àÏï°: {settled:,}Ïõê\n"
                f"üéØ Ï†ÑÎûµ: {strategy_name}\n"
                f"üè¶ Í≥ÑÏ¢å: {account_no}"
            )
            print("üì® ÌÖîÎ†àÍ∑∏Îû® Î©îÏãúÏßÄ Ï†ÑÏÜ° ÏãúÎèÑ:", msg[:30])
            send_telegram_message(msg)

        if hasattr(self.manager, 'trade_log_table'):
            row_pos = self.manager.trade_log_table.rowCount()
            self.manager.trade_log_table.insertRow(row_pos)
            for col, value in enumerate(row):
                item = QTableWidgetItem(str(value))
                item.setTextAlignment(Qt.AlignCenter if col in [0, 1, 2, 3, 5, 12] else Qt.AlignRight)
                self.manager.trade_log_table.setItem(row_pos, col, item)

        if hasattr(self.manager, 'refresh_holdings_ui'):
            self.manager.refresh_holdings_ui()
            QTimer.singleShot(1500, self.manager.refresh_holdings_ui)
        if hasattr(self.manager, 'update_ui'):
            QTimer.singleShot(1600, self.manager.update_ui)



    def reconstruct_buy_history_from_holdings(self):
        # ‚úÖ Ïù¥ÎØ∏ Î≥µÏõêÎêú Í≤ΩÏö∞ ÏÉùÎûµ
        if self.buy_history:
            if SHOW_DEBUG:
                log_debug(None, "[‚è© Î≥µÏõê ÏÉùÎûµ] buy_historyÍ∞Ä Ïù¥ÎØ∏ Ï±ÑÏõåÏ†∏ ÏûàÏùå")
            return

        new_buy_history = {}
        new_holdings = {}

        # 1Ô∏è‚É£ holdings Í∏∞Î∞òÏúºÎ°ú buy_history Î∞è holdings Ïû¨Íµ¨ÏÑ±
        for raw_code, account_data in self.holdings.items():
            code = raw_code[1:] if raw_code.startswith("A") else raw_code

            for i, account in enumerate(self.accounts):
                if account in account_data:
                    holding = account_data[account]
                    qty = holding.get("qty", 0)
                    price = holding.get("buy_price", 0)
                    step = i + 1

                    # ‚úÖ holdings Ïû¨Íµ¨ÏÑ±ÏùÄ ÏàòÎüâÏù¥ ÏûàÏùÑ ÎïåÎßå
                    if qty > 0 and price > 0:
                        new_holdings.setdefault(code, {})[account] = {
                            "buy_price": price,
                            "qty": qty
                        }

                    # ‚úÖ buy_historyÎäî qty/price ÏóÜÏñ¥ÎèÑ step Í∏∞Ï§ÄÏúºÎ°ú Î≥µÏõê
                    if code not in new_buy_history and step:
                        new_buy_history[code] = {"price": price or 0, "step": step}
                        if SHOW_DEBUG:
                            log_debug(None, f"üîÅ {code} ‚Üí buy_history Î≥µÏõê: step={step}, price={price}")

        # 2Ô∏è‚É£ sell_history Í∏∞Î∞ò ÎàÑÎùΩ Î≥¥Ï†ï (step Ï†ïÎ≥¥ Ïú†ÏßÄ)
        for code, sell_info in self.sell_history.items():
            if code not in new_buy_history:
                new_buy_history[code] = {"price": 0, "step": sell_info.get("step", 1)}
                if SHOW_DEBUG:
                    log_debug(None, f"üìå {code} ‚Üí sell_history Í∏∞Î∞ò buy_history Ï∂îÍ∞Ä: step={sell_info.get('step', 1)}")

        self.buy_history = new_buy_history
        self.holdings = new_holdings

        if SHOW_DEBUG:
            log_debug(None, f"‚úÖ buy_history Î≥µÏõê ÏôÑÎ£å: {len(new_buy_history)} Ï¢ÖÎ™©")
            self.print_holdings_summary()  # üîç ÏûêÎèô Î≥µÏõê ÏßÅÌõÑ Î≥¥Ïú† ÏÉÅÌÉú ÌôïÏù∏




    def reconstruct_sell_history_from_holdings(self):
        # Ï†ÑÏ≤¥ Ï¢ÖÎ™© Î™©Î°ù: buy_history + holdings ÌÇ§ ÌÜµÌï©
        all_codes = set(self.buy_history.keys()) | set(self.holdings.keys())

        for code in list(all_codes):
            # ‚úÖ Î™®Îì† Í≥ÑÏ¢åÏóêÏÑú Ìï¥Îãπ Ï¢ÖÎ™©ÏùÑ Î≥¥Ïú†ÌïòÍ≥† ÏûàÏßÄ ÏïäÏúºÎ©¥ ‚Üí Îß§ÎèÑ Í∏∞Î°ù Î≥µÏõê
            no_holding = all(
                acc not in self.holdings.get(code, {}) or self.holdings[code][acc].get("qty", 0) <= 0
                for acc in self.accounts
            )

            if no_holding:
                step = self.buy_history.get(code, {}).get("step", 1)
                self.sell_history[code] = {"step": step}

                if SHOW_DEBUG:
                    log_debug(None, f"üîÅ {code} Îß§ÎèÑÍ∏∞Î°ù Î≥µÏõêÎê® (step={step})")

    def reconstruct_pending_buys_from_unsettled(self):
        if not hasattr(self.manager, 'unsettled_table'):
            return

        table = self.manager.unsettled_table
        rows = table.rowCount()

        for row in range(rows):
            name_item = table.item(row, 1)
            type_item = table.item(row, 2)
            remain_item = table.item(row, 5)

            if not name_item or not type_item or not remain_item:
                continue

            name = name_item.text().strip()
            order_type = type_item.text().strip()
            remain_qty = int(remain_item.text().replace(",", "") or "0")

            if remain_qty > 0 and "Îß§Ïàò" in order_type:
                # Ïù¥Î¶ÑÏúºÎ°ú ÏΩîÎìú Ï∞æÍ∏∞
                code = self.get_code_by_name(name)
                account = self.manager.current_account
                if code and account:
                    self.pending_buys.add((code, account))
                    log_debug(None, f"‚è≥ ÎØ∏Ï≤¥Í≤∞ Î≥µÏõê: {code} / Í≥ÑÏ¢å={account} ‚Üí Ï≤¥Í≤∞ ÎåÄÍ∏∞ Îì±Î°ùÎê®")

    def get_code_by_name(self, name):
        for code, info in self.basic_info_map.items():
            if info.get("name") == name:
                return code
        return None

    def set_manager(self, manager):
        self.manager = manager
         

    def print_holdings_summary(self):
        print("üìã [Î≥¥Ïú† Ï¢ÖÎ™© ÏöîÏïΩ]")
        for code, acc_map in self.holdings.items():
            print(f"üì¶ Ï¢ÖÎ™©ÏΩîÎìú: {code}")
            for acc, info in acc_map.items():
                qty = info.get("qty", 0)
                price = info.get("buy_price", 0)
                print(f"  ‚îî Í≥ÑÏ¢å: {acc} | ÏàòÎüâ: {qty} | Îã®Í∞Ä: {price}")
                
    def log_once(self, message: str):
        if not hasattr(self, "_logged_messages"):
            self._logged_messages = set()
        if message not in self._logged_messages:
            self._logged_messages.add(message)
            log_debug(None, message)
